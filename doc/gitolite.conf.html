<p><head><style>
    body        { margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { background: #ffb; margin-left: -30px;   border-bottom: 5px  solid #ccc; }
    h2, h3      { background: #ffb; margin-left: -30px;   border-top:    3px  solid #ddd; }
    h4, h5      { background: #ffb; margin-left: -20px; }
    code        { font-size:    1.1em;  background:  #ddf; }
    pre         { margin-left:  2em;    background:  #ddf; }
    pre code    { font-size:    1.1em;  background:  #ddf; }
</style></head></p>

<h1>the access control file <code>gitolite.conf</code></h1>

<p>In this document:</p>

<ul>
<li><a href="#_syntax">syntax</a>
<ul>
<li><a href="#_continuation_lines">continuation lines</a></li>
<li><a href="#_include_files">include files</a></li>
</ul></li>
<li><a href="#_basic_access_control">basic access control</a>
<ul>
<li><a href="#_how_rules_are_matched">how rules are matched</a></li>
<li><a href="#_branches_tags_and_specifying_refex_es">branches, tags, and specifying "refex"es</a></li>
<li><a href="#_groups">groups</a>
<ul>
<li><a href="#_the_special_all_group">the special <code>@all</code> group</a></li>
</ul></li>
</ul></li>
<li><a href="#_advanced_access_control">advanced access control</a>
<ul>
<li><a href="#_creating_and_deleting_branches">creating and deleting branches</a></li>
<li><a href="#_deny_rules">"deny" rules</a>
<ul>
<li><a href="#_IMPORTANT_NOTES_ABOUT_DENY_RULES_"><strong><em>IMPORTANT NOTES ABOUT "DENY" RULES</em></strong>:</a></li>
</ul></li>
</ul></li>
<li><a href="#_summary_permissions">summary: permissions</a></li>
<li><a href="#_virtual_ref_types">virtual "ref"-types</a></li>
<li><a href="#_other_tips">other tips</a>
<ul>
<li><a href="#_personal_branches">personal branches</a></li>
<li><a href="#_splitting_up_rules_into_rulesets">splitting up rules into rulesets</a></li>
<li><a href="#_gitweb_and_daemon">gitweb and daemon</a></li>
<li><a href="#_repo_specific_git_config_commands">repo specific <code>git config</code> commands</a></li>
<li><a href="#_repo_owner_description_line_for_gitweb">repo owner/description line for gitweb</a></li>
</ul></li>
</ul>

<p>Gitolite has an advanced access control language that is designed to be
powerful but easy to use.  Other objectives were that it should be even easier
to read, review and audit the rules, and it should scale to thousands of repos
and users.  There was also, in the author's mind, a desperate need to create
something as different as possible from the brain-dead, nausea-inducing
"Windows INI" style syntax that some other popular tools seem to favour.</p>

<p>This document describes the syntax and semantics of the access control rules
and other configuration directives in the <code>gitolite.conf</code> file.</p>

<p><a name="_syntax"></a></p>

<h3>syntax</h3>

<p>In general, everything is <strong>space separated</strong>; there are no commas,
semicolons, etc., in the syntax.</p>

<p><strong>Comments</strong> are in the usual shell-ish style.</p>

<p><strong>User names</strong> and <strong>repo names</strong> are as simple as possible; they must start
with an alphanumeric, but after that they can also contain <code>.</code>, <code>_</code>, or <code>-</code>.</p>

<p>Usernames can optionally be followed by an <code>@</code> and a domainname containing at
least one <code>.</code> (this allows you to use an email address as someone's username).
Reponames can contain <code>/</code> characters (this allows you to put your repos in a
tree-structure for convenience)</p>

<p><a name="_continuation_lines"></a></p>

<h4>continuation lines</h4>

<p>There are no continuation lines -- gitolite does not process C-style
backslash-escaped newlines as anything special.  However, the section on
"groups" will tell you how you can break up large lists of names in a group
definition into multiple lines.</p>

<p><a name="_include_files"></a></p>

<h4>include files</h4>

<p>Gitolite allows you to break up the configuration into multiple files and
include them in the main file for convenience.</p>

<pre><code>include     "foo.conf"
</code></pre>

<p>will include the contents of the file "foo.conf" from the same directory as
the main config file.  You can also use an absolute path if you like, although
in the interests of cloning the admin-repo sanely you should avoid doing this!</p>

<p>You can also use a glob, as in:</p>

<pre><code>include     "*.conf"
</code></pre>

<p>which will include all the ".conf" files from the directory in which the main
config file exists.</p>

<p>Files that have been already processed once are skipped, with a warning.</p>

<p>[Advanced users: the include statement cannot be used inside a delegated
config file, for security reasons].</p>

<p><a name="_basic_access_control"></a></p>

<h3>basic access control</h3>

<p>Here's a very basic set of rules:</p>

<pre><code>repo    gitolite-admin
        RW+     =   sitaram

repo    testing
        RW+     =   @all

repo    gitolite simplicity
        RW+     =   sitaram dilbert
        RW      =   alice ashok
        R       =   wally
</code></pre>

<p>It should be easy to guess what most of this means:</p>

<ul>
<li><code>R</code> means "read" permission</li>
<li><code>RW</code> means "read and write", but no rewind</li>
<li><code>RW+</code> means "read and write", with rewind allowed</li>
</ul>

<p>A "rewind" is more often called a "non-fast forward push"; see git docs for
what that is.  The <code>+</code> was chosen because it is part of the "git push" syntax
for non-ff pushes.</p>

<p>Note that <em>tags</em> are generally considered "write once", so they are treated
specially by gitolite: you need rewind permission (<code>RW+</code>) to <em>overwrite</em> a
tag with a new value.</p>

<p>In a later section you'll see some more advanced permissions.</p>

<p><font color="gray"></p>

<p>Side note: apparently it needs to be spelled out that "R" permissions can only
apply to the entire repo and not to individual branches/tags.  Mention was
made of a certain popular Linux distribution named after animals with
adjectives, chosen merely for alliterative purposes, prefixed to their names,
and of their users not being clueful enough to know that this (the "read"
thing, not the alliterative adjective thing, in case you lost track) is an
inherent git characteristic.</p>

<p>Meanwhile, people who <em>desperately</em> need this are directed to gerrit, which
can do this because they have their own git stack and dont use the one written
by Linus and currently maintained by Junio.</p>

<p></font></p>

<p><a name="_how_rules_are_matched"></a></p>

<h4>how rules are matched</h4>

<p>It's important to understand that there're two levels at which access control
happens.  Please see <a href="http://sitaramc.github.com/gitolite/doc/3-faq-tips-etc.html#_two_levels_of_access_rights_checking">this</a> for details, especially about the first level
check.  Much of the complexity applies only to the second level check, so that
is all we will be discussing here.  This check is done by the update hook, and
determines whether the push succeeds or fails.</p>

<p>For basic permissions like this, matching is simple.  Gitolite already knows:</p>

<ul>
<li>the user</li>
<li>the repo</li>
<li>the branch or tag ("ref") being pushed</li>
<li>whether it is a normal (ff) push or a rewind (non-ff) push.</li>
</ul>

<p>Gitolite goes down the list of rules matching the user, repo, and the ref.
The first matching rule that has the permission you're looking for (<code>W</code> or
<code>+</code>), results in success.  A fallthrough results in failure.</p>

<p><a name="_branches_tags_and_specifying_refex_es"></a></p>

<h4>branches, tags, and specifying "refex"es</h4>

<p>One of the original goals of gitolite was to allow access control at the
branch/tag (aka "ref") level.  The git source code contains a sample update
hook that has the following in it:</p>

<pre><code># from Documentation/howto/update-hook-example.txt:

refs/heads/master       junio
+refs/heads/pu          junio
refs/heads/cogito$      pasky
refs/heads/bw/.*        linus
refs/heads/tmp/.*       .*
refs/tags/v[0-9].*      junio
</code></pre>

<p>If you did this in gitolite, this is what the equivalents would be:</p>

<pre><code>repo    git
        RW      master$             =   junio   # line 1
        RW+     pu$                 =   junio   # line 2
        RW      cogito$             =   pasky   # line 3
        RW      bw/                 =   linus   # line 4
        RW      tmp/                =   @all    # line 5
        RW      refs/tags/v[0-9]    =   junio   # line 6
</code></pre>

<p>The following points will help you understand these rules.  (Git recap:
branches and tags together are called "ref"s in git.  A branch ref usually
looks like "refs/heads/foo", while a tag ref looks like "refs/tags/bar")</p>

<ul>
<li><p>the general syntax of a paragraph of rules is:</p>

<pre><code># start line:
repo [one or more repos and/or repo groups]
# followed by one or more permissions lines:
[permission] [zero or more refexes] = [one or more users]
</code></pre></li>
<li><p>a <strong>refex</strong> is a <em>perl regex</em> that matches a ref.  When you try to push a
commit to a branch or a tag, that "ref" is matched against the refex part
of each rule</p></li>
<li><p>if the refex does not start with <code>refs/</code>, gitolite assumes a prefix of
<code>refs/heads/</code>.  This is useful because <em>branch</em> matching is the most
common case, as you can see this applies to lines 1 through 5 here.</p></li>
<li><p>if no refex appears, the rule applies to all refs in that repo</p></li>
<li><p>refexes are prefix-matched (they are internally anchored with <code>^</code> before
being used).  This means only the beginning of the actual ref needs to
match the refex, unless the refex has an explicit <code>$</code> meta-character at
the end (like the first 3 lines in our example do).</p>

<p>Line 5, for instance, allows anyone to push a branch inside the "tmp/"
namespace, while line 6 provides the ability to push version tags; "v1",
"v1.0", "v2.0rc1", all match the criterion specified by <code>v[0-9]</code> because
this is a prefix match only.</p></li>
</ul>

<p><a name="_groups"></a></p>

<h4>groups</h4>

<p>Gitolite allows you to define <strong>groups</strong> of repos. users, or even refexes.  A
group is semantically (but <em>not</em> syntactically) like a <code>#define</code> in C.  Here
is an example of each kind:</p>

<pre><code>@oss_repos  =   gitolite linux git perl rakudo entrans vkc
@staff      =   sitaram some_dev another-dev
@important  =   master$ QA_done refs/tags/v[0-9]
</code></pre>

<p>The syntax of a group definition is simply:</p>

<pre><code>@groupname = [one or more names]
</code></pre>

<p>A group can <em>accumulate</em> values.  For example:</p>

<pre><code>@staff      =   sitaram some_dev another-dev
@staff      =   au.thor
</code></pre>

<p>is the same as</p>

<pre><code>@staff      =   sitaram some_dev another-dev au.thor
</code></pre>

<p>This is more convenient than continuation lines, because it allows you to add
to a group anywhere.  Many people generate their gitolite.conf itself from
some <em>other</em> database, and it is very useful to be able to do this sort of
thing.</p>

<p>Groups can include other groups, and the included group will be expanded to
whatever value it <em>currently</em> has:</p>

<pre><code>@staff      =   sitaram some_dev another-dev    # line 1
@staff      =   au.thor                         # line 2
@interns    =   indy james                      # line 3
@alldevs    =   bob @interns @staff             # line 4
</code></pre>

<p>"@alldevs" expands to 7 names now.  However, remember that the config file is
parsed in a single-pass, so later <em>additions</em> to a group name cannot affect
earlier <em>uses</em> of it.  If you moved line 2 to the end, "@alldevs" would only
have 6 names in it.</p>

<p><a name="_the_special_all_group"></a></p>

<h5>the special <code>@all</code> group</h5>

<p>There's a special group called <code>@all</code> that includes all authenticated users
when used as a username; you've seen examples of it earlier.</p>

<p>[Advanced users: also see the entry for <code>GL_ALL_INCLUDES_SPECIAL</code> in
<a href="http://sitaramc.github.com/gitolite/doc/gitolite.rc.html">doc/gitolite.rc.mkd</a>.]</p>

<p>When used as a reponame, it includes all repos.</p>

<p><a name="_advanced_access_control"></a></p>

<h3>advanced access control</h3>

<p>The previous section is sufficient for most common needs, but gitolite can go
a lot further than that.</p>

<p><a name="_creating_and_deleting_branches"></a></p>

<h4>creating and deleting branches</h4>

<p>Since the beginning of gitolite, <code>RW</code> gave the ability, not only to update,
but to <em>create</em> a branch (that matched the refex).  Similarly, <code>RW+</code> meant
being able to not only rewind, but also delete a ref.  Conceptually, a rewind
is almost the same as a delete+push (the only difference I can see is if you
had core.logAllRefUpdates set, which is <em>not</em> a default setting).</p>

<p>However, there seem to be cases where it is useful to distinguish these cases.
Arguments can be made on all sides if you're dealing with new users, so
gitolite supports that.</p>

<p>We'll look at the delete/rewind case in detail first:</p>

<ul>
<li><p>if the rules for a repo do not contain a <code>D</code> anywhere, then <code>RW+</code> will
allow both rewind and delete operations.  Apart from being more convenient
if you don't need this separation, this also ensures backward
compatibility for setups created before this separation feature was added
to gitolite).</p></li>
<li><p>if, however, <em>any</em> of the rules for a repo contains a <code>D</code> (example: <code>RWD</code>,
<code>RW+D</code>, etc) then <code>RW+</code> by itself will permit only a rewind, not a delete</p></li>
</ul>

<p>The same thing applies to create/push, where if you have a permissions like
<code>RWC</code> or <code>RW+C</code> anywhere, a simple <code>RW</code> or <code>RW+</code> can no longer <em>create</em> a new
ref.</p>

<p>You can combine the <code>C</code> and <code>D</code> also.  Thus, the set of permissions you now
know about are, in regex syntax: <code>R|RW+?C?D?</code>.  See a later section for the
full set of permissions possible.</p>

<p>Some usage hints:</p>

<ul>
<li><p>if you find that <code>RW+</code> no longer allows creation/deletion but you can't
see a <code>C</code>/<code>D</code> permission in the rules, remember that gitolite allows a
repo config to be specified in multiple places for convenience, included
delegated or included files.  Be sure to search everywhere :)</p></li>
<li><p>a quick way to make this the default for <em>all</em> your repos is:</p>

<pre><code>repo @all
    RWCD    dummy-branch    =   foo
</code></pre>

<p>where foo can be either the administrator, or if you can ignore the
warning message when you push, a non-existant user.</p></li>
</ul>

<p><a name="_deny_rules"></a></p>

<h4>"deny" rules</h4>

<p>Take a look at the following snippet, which <em>seems</em> to say that "bruce" can
write versioned tags (anything containing <code>refs/tags/v[0-9]</code>), but the other
staffers can't:</p>

<pre><code>    @staff = bruce whitfield martin
            [... and later ...]
    RW refs/tags/v[0-9]     = bruce
    RW refs/tags            = @staff
</code></pre>

<p>But that's not how the matching works.  As long as any refex matches the
refname being updated, it's a "yes".  Since the second refex (which says
"anything containing <code>refs/tags</code>") is a superset of the first one, it lets
anyone on <code>@staff</code> create versioned tags, not just Bruce.</p>

<p>So how do we say "these people can create any tags except tags that look like
this pattern"?</p>

<p>One way to fix this is to allow "deny" rules.  We make a small addition to the
permissions syntax, and define a more rigorous, ordered, interpretation.</p>

<p>Let's recap the <strong>existing semantics</strong>:</p>

<blockquote>
  <p>The first matching refex that has the permission you're looking for (<code>W</code>
  or <code>+</code>), results in success.  A fallthrough results in failure.</p>
</blockquote>

<p>Here are the <strong>new semantics</strong>, with changes from the "main" one in bold:</p>

<blockquote>
  <p>The first matching refex that has the permission you're looking for (<code>W</code>
  or <code>+</code>) <strong>or a minus (<code>-</code>)</strong>, results in success <strong>or failure,
  respectively</strong>.  A fallthrough <strong>also</strong> results in failure.</p>
</blockquote>

<p>So the example we started with becomes, if you use "deny" rules:</p>

<pre><code>    RW refs/tags/v[0-9]     = bruce
    -  refs/tags/v[0-9]     = @staff
    RW refs/tags            = @staff
</code></pre>

<p>And here's how it works:</p>

<ul>
<li>for non-version tags, only the 3rd rule matches, so anyone on staff can
push them</li>
<li>for version tags by bruce, the first rule matches so he can push them</li>
<li>for version tags by staffers <em>other than bruce</em>, the second rule matches
before the third one, and it has a <code>-</code> as the permission, so the push
fails</li>
</ul>

<p><a name="_IMPORTANT_NOTES_ABOUT_DENY_RULES_"></a></p>

<h5><strong><em>IMPORTANT NOTES ABOUT "DENY" RULES</em></strong>:</h5>

<ul>
<li><p>deny rules do NOT affect read access.  They only apply to write access.</p></li>
<li><p>when using deny rules, the order of your rules starts to matter, where
earlier it did not.  If you're just starting to add a deny rule to an
existing ruleset, it's a good idea to review the entire ruleset once, to
make sure you're doing it right.</p></li>
</ul>

<p><a name="_summary_permissions"></a></p>

<h3>summary: permissions</h3>

<p>The full set of permissions, in regex syntax: <code>-|R|RW+?C?D?</code>.  This expands to
one of <code>-</code>, <code>R</code>, <code>RW</code>, <code>RW+</code>, <code>RWC</code>, <code>RW+C</code>, <code>RWD</code>, <code>RW+D</code>, <code>RWCD</code>, or
<code>RW+CD</code>.  and by now you know what they all mean.</p>

<p>[Side note: There is one more very important permissions to be dealt with --
the standalone <code>C</code>, which is not really a "ref" level permission and can be
found in doc/wildcard-repositories.mkd.]</p>

<p><a name="_virtual_ref_types"></a></p>

<h3>virtual "ref"-types</h3>

<p>This is a highly advanced topic; see <a href="http://sitaramc.github.com/gitolite/doc/virtualrefs-and-scoring.html">doc/virtualrefs-and-scoring.mkd</a> for
details.</p>

<p><a name="_other_tips"></a></p>

<h3>other tips</h3>

<p><a name="_personal_branches"></a></p>

<h4>personal branches</h4>

<p>Gitolite lets you define a "personal" or "scratch" namespace prefix for each
developer (for example, <code>refs/personal/&lt;devname&gt;/*</code>); see the "personal
branches" section in <code>doc/3-faq-tips-etc.mkd</code> for details.</p>

<p><a name="_splitting_up_rules_into_rulesets"></a></p>

<h4>splitting up rules into rulesets</h4>

<p>Gitolite lets you specify access rules for a repo in bits and pieces.  This
can be very convenient sometimes.  Let's say you have a mix of open source and
closed source projects, and "bosses" should have read access to all projects,
and everyone should have read access to open source projects.  Assuming the
appropriate group definitions, this would work:</p>

<pre><code># all bosses have read access to all projects
repo @open @closed @topsecret
    R   =   @bosses

# everyone has read access to "open" projects
repo @open
    R   =   @bosses @devs @interns
</code></pre>

<p>If you notice that <code>@bosses</code> are given read access to <code>@open</code> via both rules,
don't worry that this causes some duplication or inefficiency.  It doesn't :-)</p>

<p>Elsewhere in the file, you would specify access for individual repos (like RW,
RW+, etc).  Gitolite combines all of these access rules, maintaining the
textual order in which they occur, when authorising a push.</p>

<p>And although this example used groups, you can use reponames as well, or mix
and match them.  You can even distribute rulesets across multiple "include"
files if you wish.</p>

<p>Just remember that if you use <a href="http://sitaramc.github.com/gitolite/doc/gitolite.conf.html#_deny_rules">deny rules</a> anywhere then the <em>order of the
rules matters</em>!</p>

<p>This feature also helps people who generate their gitolite.conf itself from
some <em>other</em> database -- it allows them much more flexibility in how they
generate rules.</p>

<p><a name="_gitweb_and_daemon"></a></p>

<h4>gitweb and daemon</h4>

<p>Gitolite allows you to specify access for git-daemon and gitweb.  See
<a href="http://sitaramc.github.com/gitolite/doc/2-admin.html#gwd">this</a> for more on this.</p>

<p><a name="_repo_specific_git_config_commands"></a></p>

<h4>repo specific <code>git config</code> commands</h4>

<p>(Thanks to teemu dot matilainen at iki dot fi)</p>

<p>Sometimes you want to specify <code>git config</code> settings for some of your repos.
For example, you may have a custom post-receive hook that sends an email when
a push happens, and this hook needs to know whom to send the email to, etc.</p>

<p>You can set git config values by specifying something like this within a
"repo" paragraph:</p>

<p>example usage: if you placed a hook in hooks/common that requires
configuration information that is specific to each repo, you could do this:</p>

<pre><code>repo gitolite
    config hooks.mailinglist = gitolite-commits@example.tld
    config hooks.emailprefix = "[gitolite] "
    config foo.bar = ""
    config foo.baz =
</code></pre>

<p>The syntax is simple:</p>

<pre><code>config sectionname.keyname = [optional value_string]
</code></pre>

<p>This does either a plain "git config section.key value" (for the first 3
examples above) or "git config --unset-all section.key" (for the last
example).</p>

<p><strong>WARNING</strong>: deleting the config line from the <code>conf/gitolite.conf</code> file will
<em>not</em> delete the variable from <code>repo.git/config</code>.  The syntax in the last
example is the <em>only</em> way to make gitolite execute a <code>--unset-all</code> operation
on the given key.</p>

<p>Other forms (--add, the <code>value_regex</code>, etc) are not supported.</p>

<p><strong>Note</strong>: this won't work unless the rc file has the right settings; please
see comments around the variable <code>$GL_GITCONFIG_KEYS</code> in doc/gitolite.rc.mkd
for details and security information.</p>

<p><a name="_repo_owner_description_line_for_gitweb"></a></p>

<h4>repo owner/description line for gitweb</h4>

<p>Including a line like this:</p>

<pre><code>gitolite "Sitaram Chamarty" = "fast, secure, access control for git in a corporate environment"
</code></pre>

<p>sets the owner name and description for gitweb.  The general syntax is very
simple, just use one of:</p>

<pre><code>reponame = "some description string in double quotes"
reponame "owner name" = "some description string in double quotes"
</code></pre>

<p>Note: setting a description also gives gitweb access; you do not have to give
gitweb access explicitly (as described or linked above) if you're specifying a
description.</p>
